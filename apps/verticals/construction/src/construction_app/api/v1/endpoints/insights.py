"""
Insights API Endpoints

These endpoints READ from engine-owned tables.
They do NOT call engine implementations directly.

This creates a clean data boundary:
- Engines write to engine_* tables (via event processing)
- Verticals read from engine_* tables (via these endpoints)

Features:
- Multi-tenant isolation via auth context
- Cursor-based pagination for stable results
"""

from datetime import datetime
from typing import Any
from uuid import UUID

from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session

from construction_app.core.deps import get_current_user, get_tenant_id
from basecore.db import get_db
from construction_app.models.user import User

router = APIRouter()


def parse_cursor(cursor: str | None) -> datetime | None:
    """Parse cursor string to datetime."""
    if not cursor:
        return None
    try:
        return datetime.fromisoformat(cursor)
    except ValueError:
        return None


def format_cursor(dt: datetime | None) -> str | None:
    """Format datetime to cursor string."""
    if not dt:
        return None
    return dt.isoformat()


@router.get("/stock/alerts")
async def get_stock_alerts(
    status: str = Query("active", description="Filter by status: active, acknowledged, resolved"),
    risk_level: str | None = Query(None, description="Filter by risk level: alto, medio, baixo"),
    product_id: UUID | None = Query(None, description="Filter by product ID"),
    limit: int = Query(50, ge=1, le=200),
    cursor: str | None = Query(None, description="Pagination cursor (created_at ISO timestamp)"),
    current_user: User = Depends(get_current_user),
    tenant_id: UUID = Depends(get_tenant_id),
    db: Session = Depends(get_db),
) -> dict[str, Any]:
    """
    Get stock alerts from engine-owned tables.

    Returns alerts generated by Stock Intelligence Engine:
    - Rupture risk alerts
    - Excess stock alerts

    Pagination: Uses cursor-based pagination on created_at for stable results.
    """
    from sqlalchemy import text

    cursor_dt = parse_cursor(cursor)

    query = """
        SELECT 
            id, product_id, alert_type, risk_level, 
            current_stock, minimum_stock, days_until_rupture,
            explanation, status, created_at, updated_at
        FROM engine_stock_alerts
        WHERE tenant_id = :tenant_id AND status = :status
    """
    params: dict[str, Any] = {"tenant_id": tenant_id, "status": status}

    if cursor_dt:
        query += " AND created_at < :cursor"
        params["cursor"] = cursor_dt

    if risk_level:
        query += " AND risk_level = :risk_level"
        params["risk_level"] = risk_level

    if product_id:
        query += " AND product_id = :product_id"
        params["product_id"] = product_id

    query += " ORDER BY created_at DESC LIMIT :limit"
    params["limit"] = limit + 1  # Fetch one extra to determine if there's more

    result = db.execute(text(query), params)

    alerts = []
    for row in result:
        alerts.append({
            "id": str(row[0]),
            "product_id": str(row[1]),
            "alert_type": row[2],
            "risk_level": row[3],
            "current_stock": row[4],
            "minimum_stock": row[5],
            "days_until_rupture": row[6],
            "explanation": row[7],
            "status": row[8],
            "created_at": row[9].isoformat() if row[9] else None,
            "updated_at": row[10].isoformat() if row[10] else None,
        })

    # Determine next cursor
    has_more = len(alerts) > limit
    if has_more:
        alerts = alerts[:limit]

    next_cursor = None
    if has_more and alerts:
        next_cursor = alerts[-1]["created_at"]

    return {
        "alerts": alerts,
        "count": len(alerts),
        "next_cursor": next_cursor,
        "has_more": has_more,
        "filters": {
            "status": status,
            "risk_level": risk_level,
            "product_id": str(product_id) if product_id else None,
        },
    }


@router.get("/stock/replenishment")
async def get_replenishment_suggestions(
    status: str = Query("pending", description="Filter by status: pending, accepted, rejected"),
    priority: str | None = Query(None, description="Filter by priority: alta, media, baixa"),
    product_id: UUID | None = Query(None, description="Filter by product ID"),
    limit: int = Query(50, ge=1, le=200),
    cursor: str | None = Query(None, description="Pagination cursor (created_at ISO timestamp)"),
    current_user: User = Depends(get_current_user),
    tenant_id: UUID = Depends(get_tenant_id),
    db: Session = Depends(get_db),
) -> dict[str, Any]:
    """
    Get replenishment suggestions from engine-owned tables.

    Returns suggestions generated by Stock Intelligence Engine.
    """
    from sqlalchemy import text

    cursor_dt = parse_cursor(cursor)

    query = """
        SELECT 
            id, product_id, suggested_quantity, current_stock,
            minimum_stock, maximum_stock, priority,
            explanation, status, created_at, updated_at
        FROM engine_replenishment_suggestions
        WHERE tenant_id = :tenant_id AND status = :status
    """
    params: dict[str, Any] = {"tenant_id": tenant_id, "status": status}

    if cursor_dt:
        query += " AND created_at < :cursor"
        params["cursor"] = cursor_dt

    if priority:
        query += " AND priority = :priority"
        params["priority"] = priority

    if product_id:
        query += " AND product_id = :product_id"
        params["product_id"] = product_id

    query += " ORDER BY created_at DESC LIMIT :limit"
    params["limit"] = limit + 1

    result = db.execute(text(query), params)

    suggestions = []
    for row in result:
        suggestions.append({
            "id": str(row[0]),
            "product_id": str(row[1]),
            "suggested_quantity": row[2],
            "current_stock": row[3],
            "minimum_stock": row[4],
            "maximum_stock": row[5],
            "priority": row[6],
            "explanation": row[7],
            "status": row[8],
            "created_at": row[9].isoformat() if row[9] else None,
            "updated_at": row[10].isoformat() if row[10] else None,
        })

    has_more = len(suggestions) > limit
    if has_more:
        suggestions = suggestions[:limit]

    next_cursor = None
    if has_more and suggestions:
        next_cursor = suggestions[-1]["created_at"]

    return {
        "suggestions": suggestions,
        "count": len(suggestions),
        "next_cursor": next_cursor,
        "has_more": has_more,
        "filters": {
            "status": status,
            "priority": priority,
            "product_id": str(product_id) if product_id else None,
        },
    }


@router.get("/sales/suggestions")
async def get_sales_suggestions(
    suggestion_type: str | None = Query(None, description="Filter by type: complementary, substitute, bundle"),
    source_product_id: UUID | None = Query(None, description="Filter by source product ID"),
    status: str = Query("active", description="Filter by status"),
    limit: int = Query(50, ge=1, le=200),
    cursor: str | None = Query(None, description="Pagination cursor (created_at ISO timestamp)"),
    current_user: User = Depends(get_current_user),
    tenant_id: UUID = Depends(get_tenant_id),
    db: Session = Depends(get_db),
) -> dict[str, Any]:
    """
    Get sales suggestions from engine-owned tables.

    Returns suggestions generated by Sales Intelligence Engine:
    - Complementary products
    - Substitute products
    - Bundles
    """
    from sqlalchemy import text

    cursor_dt = parse_cursor(cursor)

    query = """
        SELECT 
            id, suggestion_type, source_product_id, suggested_product_id,
            frequency, priority, explanation, status, created_at, updated_at
        FROM engine_sales_suggestions
        WHERE tenant_id = :tenant_id AND status = :status
    """
    params: dict[str, Any] = {"tenant_id": tenant_id, "status": status}

    if cursor_dt:
        query += " AND created_at < :cursor"
        params["cursor"] = cursor_dt

    if suggestion_type:
        query += " AND suggestion_type = :suggestion_type"
        params["suggestion_type"] = suggestion_type

    if source_product_id:
        query += " AND source_product_id = :source_product_id"
        params["source_product_id"] = source_product_id

    query += " ORDER BY created_at DESC LIMIT :limit"
    params["limit"] = limit + 1

    result = db.execute(text(query), params)

    suggestions = []
    for row in result:
        suggestions.append({
            "id": str(row[0]),
            "suggestion_type": row[1],
            "source_product_id": str(row[2]) if row[2] else None,
            "suggested_product_id": str(row[3]),
            "frequency": row[4],
            "priority": row[5],
            "explanation": row[6],
            "status": row[7],
            "created_at": row[8].isoformat() if row[8] else None,
            "updated_at": row[9].isoformat() if row[9] else None,
        })

    has_more = len(suggestions) > limit
    if has_more:
        suggestions = suggestions[:limit]

    next_cursor = None
    if has_more and suggestions:
        next_cursor = suggestions[-1]["created_at"]

    return {
        "suggestions": suggestions,
        "count": len(suggestions),
        "next_cursor": next_cursor,
        "has_more": has_more,
        "filters": {
            "suggestion_type": suggestion_type,
            "source_product_id": str(source_product_id) if source_product_id else None,
            "status": status,
        },
    }


@router.get("/sales/complementary/{product_id}")
async def get_complementary_products(
    product_id: UUID,
    limit: int = Query(10, ge=1, le=50),
    current_user: User = Depends(get_current_user),
    tenant_id: UUID = Depends(get_tenant_id),
    db: Session = Depends(get_db),
) -> dict[str, Any]:
    """
    Get complementary products for a specific product.

    Useful for cart suggestions.
    """
    from sqlalchemy import text

    query = """
        SELECT 
            suggested_product_id, frequency, priority, explanation
        FROM engine_sales_suggestions
        WHERE tenant_id = :tenant_id 
          AND source_product_id = :product_id
          AND suggestion_type = 'complementary'
          AND status = 'active'
        ORDER BY frequency DESC
        LIMIT :limit
    """

    result = db.execute(
        text(query),
        {"tenant_id": tenant_id, "product_id": product_id, "limit": limit},
    )

    suggestions = []
    for row in result:
        suggestions.append({
            "product_id": str(row[0]),
            "frequency": row[1],
            "priority": row[2],
            "explanation": row[3],
        })

    return {
        "source_product_id": str(product_id),
        "complementary_products": suggestions,
        "count": len(suggestions),
    }


@router.get("/supplier/price-alerts")
async def get_supplier_price_alerts(
    status: str = Query("active", description="Filter by status"),
    product_id: UUID | None = Query(None, description="Filter by product ID"),
    supplier_id: UUID | None = Query(None, description="Filter by supplier ID"),
    limit: int = Query(50, ge=1, le=200),
    cursor: str | None = Query(None, description="Pagination cursor"),
    current_user: User = Depends(get_current_user),
    tenant_id: UUID = Depends(get_tenant_id),
    db: Session = Depends(get_db),
) -> dict[str, Any]:
    """
    Get supplier price alerts from engine-owned tables.

    Returns alerts generated by Pricing & Supplier Intelligence Engine.
    """
    from sqlalchemy import text

    cursor_dt = parse_cursor(cursor)

    query = """
        SELECT 
            id, product_id, supplier_id, alert_type,
            current_price, reference_price, price_change_percent,
            explanation, status, created_at, updated_at
        FROM engine_supplier_price_alerts
        WHERE tenant_id = :tenant_id AND status = :status
    """
    params: dict[str, Any] = {"tenant_id": tenant_id, "status": status}

    if cursor_dt:
        query += " AND created_at < :cursor"
        params["cursor"] = cursor_dt

    if product_id:
        query += " AND product_id = :product_id"
        params["product_id"] = product_id

    if supplier_id:
        query += " AND supplier_id = :supplier_id"
        params["supplier_id"] = supplier_id

    query += " ORDER BY created_at DESC LIMIT :limit"
    params["limit"] = limit + 1

    result = db.execute(text(query), params)

    alerts = []
    for row in result:
        alerts.append({
            "id": str(row[0]),
            "product_id": str(row[1]),
            "supplier_id": str(row[2]),
            "alert_type": row[3],
            "current_price": row[4],
            "reference_price": row[5],
            "price_change_percent": row[6],
            "explanation": row[7],
            "status": row[8],
            "created_at": row[9].isoformat() if row[9] else None,
            "updated_at": row[10].isoformat() if row[10] else None,
        })

    has_more = len(alerts) > limit
    if has_more:
        alerts = alerts[:limit]

    next_cursor = None
    if has_more and alerts:
        next_cursor = alerts[-1]["created_at"]

    return {
        "alerts": alerts,
        "count": len(alerts),
        "next_cursor": next_cursor,
        "has_more": has_more,
        "filters": {
            "status": status,
            "product_id": str(product_id) if product_id else None,
            "supplier_id": str(supplier_id) if supplier_id else None,
        },
    }
